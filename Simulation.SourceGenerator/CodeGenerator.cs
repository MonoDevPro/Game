using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Simulation.SourceGenerator
{
    internal static class CodeGenerator
    {
        public static string Generate(List<ComponentSyncGenerator.StructInfo> allStructs)
        {
            var sb = new StringBuilder();

            sb.AppendLine("// <auto-generated />");
            sb.AppendLine("using System;");
            sb.AppendLine("using System.Collections.Generic;");
            sb.AppendLine("using System.Buffers;");
            sb.AppendLine("using System.Linq;");
            sb.AppendLine("using System.Threading;");
            sb.AppendLine("using LiteNetLib.Utils;"); // assume LiteNetLib
            sb.AppendLine("using LiteNetLib;"); // for NetPacketReader
            sb.AppendLine("using MemoryPack;");      // assume MemoryPack
            sb.AppendLine("using Arch.Core;");       // for World
            sb.AppendLine("using Simulation.Core.Server.Systems;"); // for PlayerIndex
            sb.AppendLine("using Simulation.Core.Shared.Network;"); // for NetworkManager
            sb.AppendLine("using Simulation.Abstractions.Network;"); // for IPacket
            sb.AppendLine();
            sb.AppendLine("namespace Simulation.Generated.Network");
            sb.AppendLine("{");

            // PacketType enum (one type per struct)
            sb.AppendLine("    internal enum PacketType : byte");
            sb.AppendLine("    {");
            sb.AppendLine("        Unknown = 0,");
            for (int i = 0; i < allStructs.Count; i++)
            {
                var s = allStructs[i];
                var name = SanitizeIdentifier(s.Name);
                sb.AppendLine($"        {name}Update = {i + 1},");
            }
            sb.AppendLine("    }");
            sb.AppendLine();

            // Generate packet struct for each component type
            foreach (var s in allStructs)
            {
                var name = SanitizeIdentifier(s.Name);
                var ns = s.Namespace;
                // Packet carries PlayerId (int) + Data (the component)
                sb.AppendLine($"    [MemoryPackable]");
                sb.AppendLine($"    internal partial struct {name}UpdatePacket : IPacket");
                sb.AppendLine("    {");
                sb.AppendLine("        public int PlayerId { get; set; }");
                sb.AppendLine($"        public {ns}.{s.Name} Data {{ get; set; }}");
                sb.AppendLine("    }");
                sb.AppendLine();
            }

            // PacketProcessor class
            sb.AppendLine("    internal static class PacketProcessor");
            sb.AppendLine("    {");
            sb.AppendLine("        // Main processing entry. Keep it robust: never throw on malformed packets.");
            sb.AppendLine("        public static void Process(World world, PlayerIndexSystem playerIndex, NetPacketReader reader)");
            sb.AppendLine("        {");
            sb.AppendLine("            try");
            sb.AppendLine("            {");
            sb.AppendLine("                if (reader == null) return;");
            sb.AppendLine("                // read packet kind first (assuming first byte identifies)");
            sb.AppendLine("                if (reader.AvailableBytes <= 0) return;");
            sb.AppendLine("                var kind = (PacketType)reader.GetByte();");
            sb.AppendLine("                var dataSeg = reader.GetRemainingBytesSegment();");
            sb.AppendLine("                if (dataSeg.Array == null || dataSeg.Count == 0) return;");
            sb.AppendLine();
            sb.AppendLine("                var span = new ReadOnlySpan<byte>(dataSeg.Array, dataSeg.Offset, dataSeg.Count);");
            sb.AppendLine();
            sb.AppendLine("                switch (kind)");
            sb.AppendLine("                {");

            foreach (var s in allStructs)
            {
                var name = SanitizeIdentifier(s.Name);
                var ns = s.Namespace;
                sb.AppendLine($"                    case PacketType.{name}Update:");
                sb.AppendLine("                    {");
                sb.AppendLine("                        try");
                sb.AppendLine("                        {");
                sb.AppendLine($"                            var packet = MemoryPackSerializer.Deserialize<{name}UpdatePacket>(span);");
                sb.AppendLine();
                sb.AppendLine("                            // find entity for player");
                sb.AppendLine("                            if (!playerIndex.TryGetEntity(packet.PlayerId, out var entity))");
                sb.AppendLine("                                break; // unknown player");
                sb.AppendLine();
                sb.AppendLine($"                            // Add or set component on the entity (assumes ArchECS API world.Set<T>)");
                sb.AppendLine($"                            world.Set<{ns}.{s.Name}>(entity, packet.Data);");
                sb.AppendLine("                        }");
                sb.AppendLine("                        catch (Exception ex)");
                sb.AppendLine("                        {");
                sb.AppendLine("                            // log or swallow; be resilient to malformed packets");
                sb.AppendLine("                            Console.WriteLine($\"Failed to process packet: {ex.Message}\");");
                sb.AppendLine("                        }");
                sb.AppendLine("                        break;");
                sb.AppendLine("                    }");
            }

            sb.AppendLine("                    default:");
            sb.AppendLine("                        break;");
            sb.AppendLine("                }");
            sb.AppendLine("            }");
            sb.AppendLine("            catch (Exception ex)");
            sb.AppendLine("            {");
            sb.AppendLine("                // protect the receive loop from any unexpected exception");
            sb.AppendLine("                try { Console.WriteLine($\"PacketProcessor top-level error: {ex.Message}\"); } catch {}");
            sb.AppendLine("            }");
            sb.AppendLine("        }");
            sb.AppendLine("    }");

            // PacketFactory class
            sb.AppendLine();
            sb.AppendLine("    internal static class PacketFactory");
            sb.AppendLine("    {");
            sb.AppendLine("        public static PacketType GetPacketType<T>(T packet) where T : IPacket");
            sb.AppendLine("        {");
            sb.AppendLine("            return packet switch");
            sb.AppendLine("            {");
            
            foreach (var s in allStructs)
            {
                var name = SanitizeIdentifier(s.Name);
                sb.AppendLine($"                {name}UpdatePacket => PacketType.{name}Update,");
            }
            
            sb.AppendLine("                _ => PacketType.Unknown");
            sb.AppendLine("            };");
            sb.AppendLine("        }");
            sb.AppendLine("    }");

            sb.AppendLine("}"); // end namespace

            return sb.ToString();
        }

        /// <summary>
        /// Sanitiza identificadores para evitar caracteres inválidos ao gerar nomes de símbolo.
        /// </summary>
        private static string SanitizeIdentifier(string name)
        {
            if (string.IsNullOrEmpty(name)) return "X";
            var sb = new StringBuilder();
            foreach (var c in name)
            {
                if (char.IsLetterOrDigit(c) || c == '_') sb.Append(c);
                else sb.Append('_');
            }
            // evitar começar com dígito
            if (char.IsDigit(sb[0])) sb.Insert(0, '_');
            return sb.ToString();
        }
    }
}