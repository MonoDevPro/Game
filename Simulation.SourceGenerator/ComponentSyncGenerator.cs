using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

namespace Simulation.SourceGenerator;

[Generator]
public class ComponentSyncGenerator : IIncrementalGenerator
{
    private const string AttributeName = "Simulation.Network.Attributes.SynchronizedComponentAttribute";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var structDeclarations = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                AttributeName,
                predicate: (node, _) => node is StructDeclarationSyntax,
                transform: (ctx, _) => (StructDeclarationSyntax)ctx.TargetNode)
            .Collect();

        context.RegisterSourceOutput(structDeclarations, Execute);
    }

    private void Execute(SourceProductionContext context, ImmutableArray<StructDeclarationSyntax> structs)
    {
        if (structs.IsDefaultOrEmpty)
        {
            return;
        }

        var distinctStructs = structs.Distinct();

        var sb = new StringBuilder();

        sb.AppendLine(@"// <auto-generated/>
using Simulation.Network;
using Simulation.Components;
using Arch.Core;
using MemoryPack;
using LiteNetLib;
using LiteNetLib.Utils;

namespace Simulation.Network.Generated
{
    public enum PacketType : byte
    {");
        // Gerar Enum de Tipos de Pacote
        foreach (var structSyntax in distinctStructs)
        {
            var structName = structSyntax.Identifier.Text;
            sb.AppendLine($"        {structName}Update,");
        }
        sb.AppendLine(@"    }

");

        // Gerar Structs de Pacote
        foreach (var structSyntax in distinctStructs)
        {
            var structName = structSyntax.Identifier.Text;
            sb.AppendLine($@"    [MemoryPackable]
    public partial struct {structName}UpdatePacket : IPacket
    {{
        public Entity Entity {{ get; set; }}
        public {structName} Data {{ get; set; }}
    }}
");
        }

        // Gerar Packet Processor
        sb.AppendLine(@"    public static class PacketProcessor
    {
        public static void Process(NetPeer peer, NetPacketReader reader)
        {
            var type = (PacketType)reader.GetByte();
            // TODO: Despachar para sistemas/eventos
            // Este é um ponto de entrada para a lógica do seu jogo
            // Por enquanto, apenas imprimimos no console.
            System.Console.WriteLine($""Received packet of type: {type}"");
        }

        // Exemplo de como você poderia enviar um pacote (não usado diretamente aqui)
        public static void SendPacket<T>(NetManager manager, NetPeer peer, T packet, DeliveryMethod deliveryMethod) where T : IPacket
        {
            var writer = new NetDataWriter();
            var packetBytes = MemoryPackSerializer.Serialize(packet);

            // Escrevemos o tipo do pacote primeiro
            // writer.Put((byte)GetPacketType(packet));
            writer.Put(packetBytes);
            peer.Send(writer, deliveryMethod);
        }
    }
}
");

        context.AddSource("ComponentSync.g.cs", sb.ToString());
    }
}