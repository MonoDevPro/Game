using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

namespace Simulation.SourceGenerator
{
    internal record struct StructInfo(string Name, string Namespace, string Authority);

    [Generator]
    public class ComponentSyncGenerator : IIncrementalGenerator
    {
        private const string AttributeName = "Simulation.Core.Shared.Network.Attributes.SynchronizedComponentAttribute";

        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            var provider = context.SyntaxProvider
                .ForAttributeWithMetadataName(
                    AttributeName,
                    (node, _) => node is StructDeclarationSyntax,
                    (ctx, _) =>
                    {
                        var structSyntax = (StructDeclarationSyntax)ctx.TargetNode;
                        var attribute = ctx.Attributes.First();
                        var authority = attribute.ConstructorArguments[0].Value?.ToString();
                        return new StructInfo(
                            structSyntax.Identifier.Text,
                            structSyntax.GetNamespace(),
                            authority == "0" ? "Server" : "Client"
                        );
                    })
                .Collect();
            context.RegisterSourceOutput(provider, Execute);
        }

        private void Execute(SourceProductionContext context, ImmutableArray<StructInfo> structs)
        {
            if (structs.IsDefaultOrEmpty) return;
            var distinctStructs = structs.Distinct().ToArray();
            var serverAuthStructs = distinctStructs.Where(s => s.Authority == "Server").ToList();
            var clientAuthStructs = distinctStructs.Where(s => s.Authority == "Client").ToList();
            var code = GenerateCode(distinctStructs, serverAuthStructs, clientAuthStructs);
            context.AddSource("Network.g.cs", code);
        }
        
        private string GenerateCode(IEnumerable<StructInfo> allStructs, List<StructInfo> serverStructs, List<StructInfo> clientStructs)
        {
            var sb = new StringBuilder();
            sb.Append(@"// <auto-generated/>
#pragma warning disable
using System;
using Arch.Core;
using Arch.System;
using Arch.System.SourceGenerator;
using LiteNetLib;
using MemoryPack;
using Simulation.Core.Server.Systems;
using Simulation.Core.Shared.Network;
using Simulation.Core.Shared.Network.Contracts;
using Simulation.Core.Shared.Components;
using Simulation.Core.Shared.Network.Attributes;

namespace Simulation.Core.Shared.Network.Generated
{
    public enum PacketType : byte
    {");
            foreach (var s in allStructs) sb.AppendLine($"        {s.Name}Update,");
            sb.AppendLine("    }");

            foreach (var s in allStructs)
            {
                sb.AppendLine($@"
    [MemoryPackable]
    public struct {s.Name}UpdatePacket : IPacket
    {{
        public int PlayerId {{ get; set; }}
        public {s.Name} Data {{ get; set; }}
    }}");
            }
            sb.Append(@"
    // ===================================
    // PACKET FACTORY
    // ===================================
    public static class PacketFactory
    {
        public static PacketType GetPacketType<T>(T packet) where T : IPacket => packet switch
        {");
            foreach (var s in allStructs) sb.AppendLine($"            {s.Name}UpdatePacket _ => PacketType.{s.Name}Update,");
            sb.AppendLine("            _ => throw new ArgumentOutOfRangeException(nameof(packet), $\"Unknown packet type: {typeof(T).Name}\")");
            sb.AppendLine("        };");
            sb.AppendLine("    }");
            
            sb.Append(@"
    // ===================================
    // PACKET PROCESSOR (Called by NetworkManager)
    // ===================================
    public static class PacketProcessor
    {
        public static void Process(World world, PlayerIndexSystem playerIndex, NetPacketReader reader)
        {
            if (reader.AvailableBytes == 0) return;
            var type = (PacketType)reader.GetByte();
            var dataSpan = reader.GetRemainingBytesSegment();
            switch (type)
            {");
            foreach (var s in allStructs)
            {
                sb.AppendLine($@"                case PacketType.{s.Name}Update:
                {{
                    var packet = MemoryPackSerializer.Deserialize<{s.Name}UpdatePacket>(dataSpan);
                    if (playerIndex.TryGetEntity(packet.PlayerId, out var entity))
                    {{
                        ref var comp = ref world.AddOrGet<{s.Name}>(entity);
                        comp = packet.Data;
                    }}
                    break;
                }}");
            }
            sb.AppendLine(@"
            }
        }
    }");

            sb.AppendLine(@"
    public partial class GeneratedServerSyncSystem(World world, NetworkManager networkManager) : BaseSystem<World, float>(world)
    {");
            foreach (var s in serverStructs) {
                sb.AppendLine($"        [Query] [All<{s.Name}, PlayerId>] private void Sync{s.Name}(in PlayerId id, in {s.Name} comp) => networkManager.Broadcast(new {s.Name}UpdatePacket {{ PlayerId = id.Value, Data = comp }}, DeliveryMethod.Unreliable);");
            }
            sb.AppendLine(@"
    }");

            sb.AppendLine(@"
    public partial class GeneratedClientIntentSystem(World world, NetworkManager networkManager) : BaseSystem<World, float>(world)
    {");
            if (clientStructs.Any()) {
                foreach (var s in clientStructs) {
                    sb.AppendLine($@"        [Query] [All<{s.Name}, PlayerId>] private void Send{s.Name}(in Entity entity, in PlayerId id, in {s.Name} comp)
        {{
            networkManager.SendToServer(new {s.Name}UpdatePacket {{ PlayerId = id.Value, Data = comp }}, DeliveryMethod.ReliableOrdered);
            World.Remove<{s.Name}>(entity);
        }}");
                }
            }
            sb.AppendLine(@"
        public override void Update(in float t) {}
    }
}
");
            return sb.ToString();
        }
    }
    
    public static class SyntaxNodeExtensions
    {
        public static string GetNamespace(this BaseTypeDeclarationSyntax syntax)
        {
            var potentialNamespace = syntax.Parent;
            while (potentialNamespace != null &&
                   !(potentialNamespace is NamespaceDeclarationSyntax) &&
                   !(potentialNamespace is FileScopedNamespaceDeclarationSyntax))
            {
                potentialNamespace = potentialNamespace.Parent;
            }
            return (potentialNamespace as BaseNamespaceDeclarationSyntax)?.Name.ToString() ?? "Global";
        }
    }
}